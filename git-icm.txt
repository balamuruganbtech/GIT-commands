git init
git config --list
git config --global user.name "Balamurugan Durairajan"
git config --global user.password "J9oqTUUNCv1RJ6dcJUXz"
git clone https://IRN-7736:yEWNzvYy3nUD1A1YbgX4@gitlabee.dt.renault.com/IRN-7736/icm.git ( Authenticate with GitHub using a token)
git status -s
git add . (add all folders with files to local repository)ut
git commit -m "initial commit"(local repository committed)
git pull origin master (it will check if already exisits commit means we have to take update and then commit)
git branch(show current branch)
git push



git clone -b integration https://gitlabee.dt.renault.com/IRN-7736/icm.git
git clone -b integration https://IRN-7736:yEWNzvYy3nUD1A1YbgX4@gitlabee.dt.renault.com/IRN-7736/icm.git

git clone -b Acceptance https://gitlabee.dt.renault.com/IRN-7736/icm.git
 


yEWNzvYy3nUD1A1YbgX4 originaltoken
tRxoT4FBoY1N3NUrgiRh feedtoken


git status
git add .
git pull
git commit -m "hi i committed my code"
git push

git -c http.sslVerify=false clone -b 19.5_DEV2 https://IRN-7736:yEWNzvYy3nUD1A1YbgX4@gitlabee.dt.renault.com/IRN-7736/icm.git ( Authenticate with GitHub using a token)

new token:
J9oqTUUNCv1RJ6dcJUXz

feed token:
tRxoT4FBoY1N3NUrgiRh

Git status - is there a way to show changes only in a specific directory ?
git status <directoryPath>
git status .
. - means here current directory

Difference between files in git ?
git diff FFSCompoTemplates.xsl


GIT vs SVN ?
	1. Decentralized
			GIT - is decentralized. you have a local copy that is repository in which you can commit. 
			SVN - you have always to connect central repository for check in.
	2. complex to learn	
			GIT is bit difficult to learn, it has more concepts and commands.
			SVN is easier
	3. unable to handle binary files
			GIT becomes slow when the file size is very large
			SVN handles very easily large files
	4. internal directory
			GIT - creates internal only one directory .git
			SVN - creates internal directory .svn each folder
	

very complex questions, need to be very expert in java core and also very expert on SQL queries. They will ask spring framework questions and need to be at least expert to some extend
Hibernate connection and Normalization of tables  
Spring Boot and spring bean scopes  
Exception handling in Java  
Collections and map  
Collections and map  

CrudRepository
public class SimpleJpaRepository<T, ID> implements JpaRepository<T, ID>, JpaSpecificationExecutor<T>
EntityManagerFactory emf = 
            Persistence.createEntityManagerFactory("myPersistenceUnit"); 
        EntityManager em = emf.createEntityManager();
Transaction 
	1. ACID
	2. Transaction
		@Repository
		@Service
		@Id
		@Transactional(timeout=300)
		@EnableJpaRepositories
		@ComponentScan
		@Configuration
		@EnableTransactionManagement
	3. JPA Exceptions:
		org.springframework.orm.jpa.JpaSystemException: 
		org.hibernate.exception.ConstraintViolationException: 
		javax.persistence.PersistenceException

What is Lazy loading ?			
"Lazy loading" means that an entity will be loaded only when you actually accesses the entity for the first time.
	public Entity getEntity() {
    if (entity == null) {
        entity = loadEntity();
    }
    return entity;
}
This saves the cost of preloading/prefilling all the entities in a large dataset beforehand while you after all actually don't need all of them.
In Hibernate, you can configure to lazily load a collection of child entities. The actual lazy loading is then done inside the methods of the PersistentSet which Hibernate uses "under the hoods" to assign the collection of entities as Set.

Bydefault lazy loading is true.Lazy loading means when the select query is executed it will not hit the database. It will wait for getter function
 i.e when we required then ,it will fetch from the datbase. for example: You are a parent who has a kid with a lot of toys. But the current issue is whenever you call him (we assume you have a boy), he comes to you with all his toys as well. Now this is an issue since you do not want him carrying around his toys all the time. 
So being the rationale parent, you go right ahead and define the toys of the child as LAZY. Now whenever you call him, he just comes to you without his toys.
@OneToMany( mappedBy = "category", fetch = FetchType.LAZY )

	1. Lazy Loading
		Advantages:
			Initial load time much smaller than in the other approach
			Less memory consumption than in the other approach
		Disadvantages:
			Delayed initialization might impact performance during unwanted moments
			In some cases you need to handle lazily-initialized objects with a special care or you might end up with an exception
	2. Eager Loading:
		Advantages:
			No delayed initialization related performance impacts
		Disadvantages:
			Long initial loading time
			Loading too much unnecessary data might impact performance

	
cache:
	1. reduce network calls
	2. Avoid recomputations
	3. Reduce DB load
	Policy:
		loading and evict data
		Evict calls and thrashing
		LRU - least recently used entries
		LFU - least frequently used entries
Redis vs memcached ?

	Server end data operations:
		1. redis supports richer-end data operations on server-end, and owns more data structures than memcached
		2. In Memcached, you usually need to copy the data to the client end for similiar changes and then set the data back. the result is that is greatly
		    increases the network IO counts and data sizes.
		3. In redis these complicated operations are as efficients as the general GET/SET operations.
	Memory use effiency operations:
		1. In memcached on inserting items the daemon quickly grows to a little more than specified size.
		2. So, there is never really way to reclaim any of the space specified for inserting items, short of restarting memcached.
		3. In redis, setting max size is up to us, it will never use more than it has to an will give back you memory it is no longer using.
	Perfomance :
		1. redis uses only single core operations but memcached uses multiple core operations
		2. So on average, redis boost higher performance than memcached in small data storage when measured interms of cores 

	Concepts:
		Read/write speed.
		Memory usage.
		Disk I/O dumping.
		Scaling.

	redis commands:
		List
			lpush/rpush/lpop/rpop/lrange.
		Set
			sadd/spop/smembers/sunion and so on.
		Sorted set:
			zadd/zrange/zrem/zcard.